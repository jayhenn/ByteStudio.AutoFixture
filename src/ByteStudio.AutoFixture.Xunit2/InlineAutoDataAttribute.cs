using System;
using System.Collections.Generic;
using System.Reflection;
using Xunit.Sdk;

namespace AutoFixture
{
    /// <summary>
    /// Provides a data source for a data theory, with the data coming from inline
    /// values combined with auto-generated data specimens generated by AutoFixture.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class InlineAutoDataAttribute : DataAttribute
    {
        /// <summary>
        /// Gets data for calling test method.
        /// </summary>
        public object[] Data { get; }

        /// <summary>
        /// Gets or sets the source used to create the <see cref="IFixture"/> during a test run.
        /// <para>Defaults to <see cref="TestMethodFixtureSource"/>.</para>
        /// </summary>
        protected ITestMethodFixtureSource TestMethodFixtureSource { get; set; } = new TestMethodFixtureSource();

        /// <summary>
        /// Gets or sets the resolver used to generate arguments for a test run.
        /// <para>Defaults to <see cref="TestMethodArgumentResolver"/>.</para>
        /// </summary>
        protected ITestMethodArgumentResolver TestMethodArgumentResolver { get; set; } = new TestMethodArgumentResolver();

        /// <summary>
        /// Initializes a new instance of the <see cref="InlineAutoDataAttribute"/> class.
        /// </summary>
        /// <param name="data1"> The data object. </param>
        public InlineAutoDataAttribute(object data1)
        {
            // Need to have this constructor explicitly to fix a CLS compliance error.
            Data = new object[] { data1 };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InlineAutoDataAttribute"/> class which takes in an array of arguments.
        /// </summary>
        /// <param name="data1"> A data object. </param>
        /// <param name="moreData"> More data. </param>
        public InlineAutoDataAttribute(object data1, params object[] moreData)
        {
            if (moreData == null)
            {
                // This actually means that the user wants to pass in a 'null' value to the test method.
                moreData = new object[] { null };
            }

            Data = new object[moreData.Length + 1];
            Data[0] = data1;
            Array.Copy(moreData, 0, Data, 1, moreData.Length);
        }

        /// <inheritdoc />
        public override IEnumerable<object[]> GetData(MethodInfo methodInfo)
        {
            var numberOfInlineData = Data.Length;
            var parameters = methodInfo.GetParameters();
            var numberOfParameters = parameters.Length;
            var numberToAutoGenerate = numberOfParameters - numberOfInlineData;

            if (numberToAutoGenerate <= 0)
                return new[] { Data };

            var arguments = new List<object>(Data);
            var testMethodInfo = methodInfo.ToTestMethodInfo().IgnoreParameters(numberOfInlineData);
            var fixture = TestMethodFixtureSource.GetFixture(testMethodInfo);
            arguments.AddRange(TestMethodArgumentResolver.GetTestMethodArguments(fixture, testMethodInfo));
            return new[] { arguments.ToArray() };
        }
    }
}
